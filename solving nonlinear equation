#include <iostream>
#include <math.h>
#define pi acos(-1)
#include"string"
using namespace std;
 
// Abstract base class
class EquationSlover
{
   public:
   virtual double Slove()=0;
    
    void setfun(string f)
    {
      func=f;
      
    }
    
    void setfun(string f1,string f2)
    {
      func=f1;
      func1=f2;
    }
    
    {
    if(function == "func_1") {
        return func_1(x);
  } else if(function == "func_2") {
        return func_2(x);} 
    else if(function == "func_5") {
        return func_5(x);}
    else if(function == "derivfunc_5") {
        return derivfunc_5(x);}
    else if(function == "func_6") {
        return func_6(x);}
    else if(function == "func_7") {
        return func_7(x);}
    else if(function == "func_8") {
        return func_8(x);}
    else if(function == "func_3"){
      return func_3(x);}
    else{
        return func_4(x);
    }
  }
   void seta(double a)
   {
      LeftInterval = a;
   }
   void setb(double b)
   {
      RightInterval = b;
   }
   protected:
   string func;
   string func1;
   double LeftInterval;
   double RightInterval;
};
 
// Derived class
class BisectionMethod: public EquationSlover
{
   public:
   double Slove()
   {
     double u=function(LeftInterval,func);
     double v=function(RightInterval,func);
      if ((u*v)>=0)
      {
         cout << "There are no roots in this interval.";
         return 0;
      }
      
      double h=LeftInterval;
      while ((RightInterval-LeftInterval)>=0.01)
      {
         h=(LeftInterval+RightInterval)/2;
         if (function(h,func)==0.0)
         break;

         else if (function(h,func)*function(LeftInterval,func)<0)
         RightInterval=h;

         else
         LeftInterval=h;
      }
      return h;
   }
};


class NewtonMethod: public EquationSlover
{
   public:
   double Slove()
   { int m=50;
     double x0=LeftInterval;
     
     for(int i=0;i<=m;i++) 
     {
       double u=function(x0,func);
       if(abs(u)<0.01)
       {break;}
       else if(x0>RightInterval)
       {
       cout << "There is no root in this interval."<<endl;
       }
       else{
         double h=function(x0,func)/function(x0,func1);
         double x1=x0-h;
         x0=x1;
       }
     }
     return x0;
    }
};


class SecantMethod: public EquationSlover
{
   public:
   double Slove()
   
   { double x_1=RightInterval;
     double x_0=LeftInterval;
     double u=function(x_1,func);
     double v=function(x_0,func);
     for(int i=2;i<=50;i++)
     {
       if (abs(u)>abs(v))
       {
         swap(x_1,x_0);
         swap(u,v);
        }
        double s=((x_1)-(x_0))/(u-v);
        x_0=x_1;
        v=u;
        x_1=x_1-u*s;
        u=function(x_1,func);
        if(abs((x_1)-(x_0))<0.01||abs(u)<0.01)
        {break;}
     }
    return x_1;
    }
    
};


int main(void)
{
  //Test1
   BisectionMethod Bis1;
   Bis1.seta(0);
   Bis1.setb(pi/2);
   string a="func_1";
   Bis1.setfun(a);
   
   cout<<"The value of root is:"<<Bis1.Slove()<<endl;
   
   
   //Test2
   BisectionMethod Bis2;
   Bis2.seta(0);
   Bis2.setb(1);
   string b="func_2";
   Bis2.setfun(b);
   
   cout<<"The value of root is:"<<Bis2.Slove()<<endl;
   
   
   //Test3
   BisectionMethod Bis3;
   Bis3.seta(1);
   Bis3.setb(3);
   string c="func_3";
   Bis3.setfun(c);
   
   cout<<"The value of root is:"<<Bis3.Slove()<<endl;
   
   
   //Test4
   BisectionMethod Bis4;
   Bis4.seta(1);
   Bis4.setb(3);
   string d="func_4";
   Bis4.setfun(d);
   
   cout<<"The value of root is:"<<Bis4.Slove()<<endl;
   
   //Test NewtonMethod
   NewtonMethod New1;
   New1.seta(4.5);
   New1.setb(7.7);
   string e="func_5";
   string f="derivfunc_5";
   New1.setfun(e,f);
   
   cout<<"The value of root is:"<<New1.Slove()<<endl;
   return 0;
   

}
