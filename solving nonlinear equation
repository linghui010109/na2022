#include <iostream>
#include <math.h>
#define pi acos(-1)
#include"string"
using namespace std;
 
// Abstract base class
class EquationSlover
{
   public:
   virtual double Slove()=0;
    
    void setfun(string f)
    {
      func=f;
      
    }
    
    void setfun(string f1,string f2)
    {
      func=f1;
      func1=f2;
    }
    
    double func_1(double x)
   {return (1/x)-tan(x);}
   
    double func_2(double x)
    {return 1/x-pow(2,x);}
    
    double func_3(double x)
    {return 1/(pow(2,x))+exp(x)+2*cos(x)-6;}
    
    double func_4(double x)
    {return (pow(x,3)+4*pow(x,2)+3*x+5)/(2*pow(x,3)-9*pow(x,2)+18*x-2);}
    
    double func_5(double x)
    {return x-tan(x);}
    
    double derivfunc_5(double x)
    {return 1-pow(1/cos(x),2);}
    
   double function(double x,string function)
  {
    if(function == "func_1") {
        return func_1(x);
  } else if(function == "func_2") {
        return func_2(x);} 
    else if(function == "func_5") {
        return func_5(x);}
    else if(function == "derivfunc_5") {
        return derivfunc_5(x);}
    else if(function == "func_3"){
      return func_3(x);}
    else{
        return func_4(x);
    }
  }
   void seta(double a)
   {
      LeftInterval = a;
   }
   void setb(double b)
   {
      RightInterval = b;
   }
   protected:
   string func;
   string func1;
   double LeftInterval;
   double RightInterval;
};
 
// Derived class
class BisectionMethod: public EquationSlover
{
   public:
   double Slove()
   {
     double u=function(LeftInterval,func);
     double v=function(RightInterval,func);
      if ((u*v)>=0)
      {
         cout << "There are no roots in this interval.";
         return 0;
      }
      
      double h=LeftInterval;
      while ((RightInterval-LeftInterval)>=0.01)
      {
         h=(LeftInterval+RightInterval)/2;
         if (function(h,func)==0.0)
         break;

         else if (function(h,func)*function(LeftInterval,func)<0)
         RightInterval=h;

         else
         LeftInterval=h;
      }
      return h;
   }
};

class NewtonMethod: public EquationSlover
{
   public:
   double Slove()
   { int m=50;
     double x0=LeftInterval;
     
     for(int i=0;i<=m;i++) 
     {
       double u=function(x0,func);
       if(abs(u)<0.01)
       {break;}
       else if(x0>RightInterval)
       {
       cout << "There is no root in this interval."<<endl;
       }
       else{
         double h=function(x0,func)/function(x0,func1);
         double x1=x0-h;
         x0=x1;
       }
     }
     return x0;
    }
};




int main(void)
{
  //Test1
   BisectionMethod Bis1;
   Bis1.seta(0);
   Bis1.setb(pi/2);
   string a="func_1";
   Bis1.setfun(a);
   
   cout<<"The value of root is:"<<Bis1.Slove()<<endl;
   
   
   //Test2
   BisectionMethod Bis2;
   Bis2.seta(0);
   Bis2.setb(1);
   string b="func_2";
   Bis2.setfun(b);
   
   cout<<"The value of root is:"<<Bis2.Slove()<<endl;
   
   
   //Test3
   BisectionMethod Bis3;
   Bis3.seta(1);
   Bis3.setb(3);
   string c="func_3";
   Bis3.setfun(c);
   
   cout<<"The value of root is:"<<Bis3.Slove()<<endl;
   
   
   //Test4
   BisectionMethod Bis4;
   Bis4.seta(1);
   Bis4.setb(3);
   string d="func_4";
   Bis4.setfun(d);
   
   cout<<"The value of root is:"<<Bis4.Slove()<<endl;
   
   //Test NewtonMethod
   NewtonMethod New1;
   New1.seta(4.5);
   New1.setb(7.7);
   string e="func_5";
   string f="derivfunc_5";
   New1.setfun(e,f);
   
   cout<<"The value of root is:"<<New1.Slove()<<endl;
   return 0;
   

}
